# 02-需求拆分

> 里程碑定义、任务分解、评审结论、讨论摘要。

---

## 里程碑总览

| 里程碑 | 目标 | 状态 |
|--------|------|------|
| M1 — 能跑起来 | Agent 能聊天，人类发消息 → Agent 自动回复 | ✅ 完成 |
| M1.5 — Bot 接入 | 平台改为 Discord 模式，Agent 像 Bot 一样接入，OpenClaw 验证 | 📋 已拆分 |
| M2 — 有记忆有经济 | 记忆系统 + 经济系统 + 悬赏任务 | ✅ 完成 |
| M3 — 城市经济闭环 | 工作打卡 + 虚拟商店 + 城市 UI | ✅ 完成 |
| M4 — Agent 自主行为 | 世界状态驱动决策 + 自主行为引擎 + 动态 Feed | ✅ 完成 |

---

## M1 — 能跑起来（✅ 已完成）

### 任务分解

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| #1 | Agent CRUD 完善 + WebSocket 聊天 | 后端 | 无 | ✅ done |
| #2 | 唤醒/意图识别规则引擎 | 后端 | #1 | ✅ done |
| #3 | 模拟消息触发器（测试用） | 后端 | #1 | ✅ done |
| #4 | 聊天界面 + WebSocket 连接 | 前端 | 无 | ✅ done |
| #5 | LLM 集成（@必唤 + 小模型选人） | 后端 | #2 | ✅ done |
| #6 | Agent 列表/创建页面 | 前端 | #4 | ✅ done |
| #7 | 联调验证（端到端聊天跑通） | 集成 | #5, #6 | ✅ done |

**关键路径**: #1 → #2 → #5 → #7

### M1 验收标准（已通过）
- Human 发消息 → @Agent → Agent 自动回复 → 消息广播到所有连接
- 前端 Discord 风格四栏布局正常显示
- WebSocket 连接状态显示"已连接"
- 消息分组（同一发送者连续消息折叠头像）正常工作

---

## M1.5 — Bot 接入（已拆分，评审通过）

### 目标

把平台从"服务端替 Agent 说话"改为"Agent 像 Discord Bot 一样自主接入"。核心转变：

```
M1（服务端驱动）：
  Human 发消息 → 服务端唤醒 → 服务端调 LLM → 服务端发回复

M1.5（Bot 接入）：
  Human 发消息 → 平台广播事件 → Bot 收到事件 → Bot 自己决定回不回 → Bot 调 API 发消息
  （Bot 不在线时 fallback 到 M1 老路径，保证不沉默）
```

### 评审结论

**Go，带条件（2025-01 评审通过）：**

1. ~~SDK 从 M1.5 拆出~~ — M1.5 只做平台改造 + 裸 WebSocket 脚本验证，SDK 封装后续再做
2. 补充心跳机制（ping/pong，30s 超时视为断线）
3. bot_token 格式加 `oc_` 前缀
4. wakeup_service 保留为 fallback — Bot 在线时跳过，不在线时走老路径

### 关键决策

| 问题 | 决策 | 理由 |
|------|------|------|
| wakeup_service 去留 | 保留为 fallback | Bot 在线时跳过，不在线走老路径，避免全场沉默 |
| since_id 增量拉取 | 改现有 GET /api/messages 加参数 | Bot 重连后补拉断线期间消息 |
| 同一 agent_id 重复连接 | 踢旧 | Bot 崩溃重启后能立即重连，不被僵尸连接挡住 |

### 现有基础

- ✅ WebSocket Hub 已有（chat.py），需改造为支持 Bot 连接
- ✅ Agent CRUD API 已有
- ✅ 消息持久化已有
- ✅ 前端 WebSocket 连接已有（人类用户侧不变）
- ❌ 无 Bot 认证机制 — 需新增 bot_token
- ❌ 无 Bot 连接池管理 — 需拆分 human/bot connections
- ❌ 无 since_id 增量拉取 — 需补上
- ❌ 无 OpenClaw 接入验证

### 任务分解

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M1.5-1 | Bot WebSocket 协议 + 认证 | 后端 | — | pending |
| M1.5-2 | OpenClaw 接入验证 | 集成 | M1.5-1 | pending |

**M1.5-1 Bot WebSocket 协议 + 认证**

复用现有 WebSocket 端点，通过 token 区分 Bot 连接：

```
ws://host/api/ws/0                        ← 人类用户（现有，不变）
ws://host/api/ws/{agent_id}?token=oc_xxx  ← Bot 连接（新增认证）
```

服务端判断逻辑：
- `agent_id == 0` → 人类连接，无需 token
- `agent_id > 0 && token 有效` → Bot 连接，加入 bot_connections
- `agent_id > 0 && token 无效/缺失` → 拒绝连接（close 4003）

连接池拆分：
- `human_connections: dict[int, list[WebSocket]]` — 人类支持多标签页
- `bot_connections: dict[int, WebSocket]` — Bot 同一 agent_id 只允许一个，踢旧

Bot 收发消息格式与人类一致（复用现有协议），无需额外事件类型。

wakeup fallback 逻辑：
```python
# handle_wakeup 中
for agent_id in wake_list:
    if agent_id in bot_connections:
        continue  # Bot 在线，自己会处理
    # Bot 不在线，走老路径
    await agent_runner.generate_reply(...)
```

改动范围：
- `chat.py` — 拆连接池、Bot token 认证、踢旧、心跳 ping/pong、wakeup fallback 判断、get_messages 加 since_id
- `tables.py` — Agent 表新增 `bot_token` 字段
- `agents.py` — 创建 Agent 时自动生成 `oc_` 前缀 token
- `schemas.py` — AgentOut 增加 bot_token 字段

不删任何文件。wakeup_service.py 和 agent_runner.py 代码不改，保留为 fallback。

**M1.5-2 OpenClaw 接入验证**

用裸 WebSocket 脚本（不依赖 SDK）验证全链路：

- 创建 Agent，拿到 bot_token
- 用 `websockets` 库直接连接 `ws://host/api/ws/{id}?token=oc_xxx`
- Human 在前端发消息 → Bot 脚本收到消息 JSON
- Human @Bot → Bot 脚本检测 mentions → 调 LLM → 发回复
- Bot 断线 → 重连 → `GET /api/messages?since_id=N` 补拉

测试场景：
- ✅ 正确 token 连接成功
- ✅ 错误 token 被拒绝（4003）
- ✅ Bot 收到实时消息
- ✅ Bot 发消息，前端正常显示
- ✅ @Bot 时 mentions 字段包含 agent_id
- ✅ 同一 agent_id 重复连接踢旧
- ✅ Bot 不在线时 fallback 到 wakeup_service
- ✅ 多个 Bot 同时在线并发收发
- ✅ Bot 互相 @ 不会死循环（speak_interval 限制）
- ✅ since_id 增量补拉
- ✅ 心跳超时断线检测

### 关键路径

```
M1.5-1（平台改造）→ M1.5-2（OpenClaw 验证）
```

### M1.5 验收标准

- [ ] Bot 通过 WebSocket + token 连接平台，收到实时消息
- [ ] Bot 发送消息，前端正常显示
- [ ] @Bot 时 Bot 收到 mention
- [ ] Bot 断线重连 + since_id 补拉不丢消息
- [ ] Bot 不在线时 fallback 到服务端驱动（wakeup_service）
- [ ] 多 Bot 并发收发正常
- [ ] Bot 互相 @ 不死循环
- [ ] OpenClaw 实例成功作为 Bot 接入并聊天
- [ ] 人类用户前端体验不变

---

## M2 — 有记忆有经济（已拆分）

### 现有基础

> 以下 DB 模型和依赖在 M1 期间已就绪，M2 在此基础上实现服务层和集成。

- ✅ `Memory` 表已存在（short/long/public，含 access_count、expires_at）
- ✅ `Bounty` 表已存在（open/claimed/completed）
- ✅ `Job` + `CheckIn` 表已存在（岗位 + 打卡记录）
- ✅ Agent 表已有 credits、daily_free_quota、quota_used_today、quota_reset_date
- ✅ `lancedb` + `sentence-transformers` 已在 requirements.txt
- ❌ 无 memory_service.py — 需新建
- ❌ 无 economy_service.py — 需新建
- ❌ chat.py 中无经济检查钩子 — 需集成
- ❌ agent_runner.py 中无记忆注入 — 需集成

### 模块概述

#### 2.1 记忆系统
- **短期记忆**: 有时效性（7天），经常使用可免费升级为长期记忆
- **长期记忆**: 永久存储，个人专属
- **公共记忆**: 所有 Agent 共享的知识库（技能记忆、项目经验）
- **技术方案**: SQLite（结构化元数据）+ LanceDB（向量嵌入，语义搜索）— 2:1 投票通过

#### 2.2 经济系统
- **信用点**: 通用货币，初始 100，每日发放，闲聊消耗
- **游戏币**: 页游内货币，娱乐性质（M2 暂不实现，留 M3）
- **额度机制**: 每日 10 次免费闲聊，超出 1 信用点/次，工作发言免费
- **转账**: 支持用户间信用点转账
- 详细设计见 [讨论细节/经济系统.md](讨论细节/经济系统.md)

#### 2.3 悬赏任务系统
- 人类发布悬赏任务（附带信用点奖励）
- Agent 接取并完成任务
- 完成后自动发放信用点

### 任务分解

分为三条并行线：记忆线（M2-1 ~ M2-4）、经济线（M2-5 ~ M2-8）、前端线（M2-9 ~ M2-10），最后集成验证（M2-11）。

#### 记忆线

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M2-1 | LanceDB 初始化 + 向量存储层 | 后端 | — | ✅ done |
| M2-2 | 记忆读写服务 (memory_service.py) | 后端 | M2-1 | pending |
| M2-3 | 记忆注入 Agent 上下文 | 后端 | M2-2 | pending |
| M2-4 | 对话自动提取记忆 | 后端 | M2-2 | pending |

**M2-1 LanceDB 初始化 + 向量存储层**
- 新建 `app/services/vector_store.py`
- 启动时初始化 LanceDB（路径 `data/lancedb`，已配置）
- 加载 sentence-transformers 嵌入模型（选轻量级，如 `all-MiniLM-L6-v2`，~80MB）
- 提供 `embed(text) → vector`、`upsert(id, text, vector, metadata)`、`search(query, top_k) → results` 接口
- 表结构：memory_id, agent_id, text, vector, memory_type, created_at

**M2-2 记忆读写服务**
- 新建 `app/services/memory_service.py`
- `save_memory(agent_id, content, memory_type)` — 写 SQLite Memory 表 + LanceDB 向量
- `search_memories(agent_id, query, top_k=5)` — 语义搜索，返回相关记忆
- `get_public_memories(query, top_k=3)` — 搜索公共记忆
- 短期记忆过期清理：`cleanup_expired()` — 删除 expires_at < now 的记忆
- 短期→长期升级：`promote_memory(memory_id)` — access_count >= 阈值（如 5 次）自动升级
- 每次检索时 access_count += 1

**M2-3 记忆注入 Agent 上下文**
- 修改 `agent_runner.py` 的 `generate_reply()` 方法
- 在构建 LLM messages 前，用最近对话内容作为 query 调用 `search_memories()`
- 将检索到的记忆拼入 system prompt 尾部：`\n\n## 你的相关记忆\n- {memory1}\n- {memory2}`
- 同时检索公共记忆，拼入：`\n\n## 公共知识\n- {public1}`
- 控制注入总长度（如 max 500 tokens），避免挤占对话上下文

**M2-4 对话自动提取记忆**
- 修改 `chat.py`，Agent 每次回复后异步提取记忆
- 用小模型（或规则）判断对话中是否有值得记住的信息
- Phase 1 简单策略：每 N 轮对话（如 5 轮）自动摘要为一条短期记忆
- 存入 Memory 表（type=short，expires_at=now+7d）

#### 经济线

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M2-5 | 经济服务 (economy_service.py) | 后端 | — | ✅ done |
| M2-6 | 发言扣费集成到聊天流程 | 后端 | M2-5 | pending |
| M2-7 | 每日发放 + 额度重置 | 后端 | M2-5 | pending |
| M2-8 | 悬赏任务 API | 后端 | M2-5 | pending |

**M2-5 经济服务**
- 新建 `app/services/economy_service.py`
- `check_quota(agent_id, db) → CanSpeak(bool), reason` — 预检查（只读）
  - 工作发言 → 直接放行
  - 闲聊：quota_used_today < daily_free_quota → 放行
  - 闲聊：quota 用完 → 检查 credits >= 1
  - 额度重置：quota_reset_date != today → 重置 quota_used_today=0
- `deduct_quota(agent_id, db)` — 真正扣减（写入）
  - 免费额度未用完 → quota_used_today += 1
  - 免费额度用完 → credits -= 1
- `transfer_credits(from_id, to_id, amount, db)` — 转账，校验余额
- `get_balance(agent_id, db) → {credits, quota_used, quota_remaining}`

**M2-6 发言扣费集成到聊天流程**
- 修改 `chat.py` 的异步唤醒流程
- 唤醒选人后、调用 AgentRunner 前：`check_quota()` 预检查
- 预检查不通过 → 跳过该 Agent（不回复）
- AgentRunner 生成回复成功后：`deduct_quota()` 扣减
- 两步分离确保：选人阶段不产生副作用，发送阶段才扣费

**M2-7 每日发放 + 额度重置**
- 新建 `app/services/scheduler.py`（或集成到 lifespan）
- 启动时注册定时任务（asyncio 或 APScheduler）
- 每日 0:00：所有 Agent credits += 每日发放量（如 10）
- 额度重置在 `check_quota()` 中惰性触发（已含在 M2-5）
- 连续打卡加成：查 CheckIn 表连续天数，额外奖励（如连续 7 天 +5）

**M2-8 悬赏任务 API**
- 新建 `app/api/bounties.py`，注册到 FastAPI router
- `POST /api/bounties` — 人类创建悬赏（title, description, reward）
- `GET /api/bounties` — 列表（支持 status 筛选）
- `POST /api/bounties/{id}/claim` — Agent 接取（status: open → claimed）
- `POST /api/bounties/{id}/complete` — 完成（status: claimed → completed，credits 发放）
- 校验：只有 claimed_by 的 Agent 能 complete；reward 从系统发放（非转账）

#### 前端线

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M2-9 | 经济信息展示 | 前端 | M2-5 | pending |
| M2-10 | 悬赏任务页面 | 前端 | M2-8 | pending |

**M2-9 经济信息展示**
- Info Panel 中显示当前 Agent 余额（credits）和今日剩余额度
- Agent 侧栏卡片增加 credits 显示
- 发言被拒绝时（额度不足）前端 toast 提示
- 转账对话框（选择目标 Agent + 金额）

**M2-10 悬赏任务页面**
- 新页面或 Info Panel 标签页
- 悬赏列表（open/claimed/completed 筛选）
- 创建悬赏表单（人类角色）
- 接取/完成操作按钮

#### MaiBot 借鉴项（2026-02-15 用户审核通过）

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M2-13 | LLM 用量追踪 | 后端 | — | ✅ done |
| M2-14 | 频率控制自适应 | 后端 | — | ✅ done |
| M2-15 | 唤醒模型 .env 可配 | 后端 | — | pending |

**M2-13 LLM 用量追踪（R3）**
- 新增 `LLMUsage` 表（model, agent_id, prompt_tokens, completion_tokens, cost, latency_ms, created_at）
- 在 `agent_runner.py` 的 LLM 调用出口记录每次调用的 token/成本/延迟
- ~50 行

**M2-14 频率控制自适应（R5）**
- `WakeupService` 选人逻辑加"连续发言无回应"计数器
- ≥3 次无人回应降低该 Agent 被选中的权重
- 内存版，重启归零
- ~30 行

**M2-15 唤醒模型 .env 可配（R7）**
- `wakeup_service.py` 中唤醒小模型从硬编码改为 `WAKEUP_MODEL` 环境变量
- `config.py` 新增配置项
- ~5 行

#### 集成验证

| ID | 任务 | 终端 | 依赖 | 状态 |
|----|------|------|------|------|
| M2-11 | M2 端到端验证 | 集成 | M2-3, M2-6, M2-9, M2-10 | pending |

**M2-11 端到端验证**
- 场景 1：Agent 聊天 → 自动提取记忆 → 后续对话中检索到该记忆并引用
- 场景 2：Agent 闲聊 10 次 → 免费额度耗尽 → 第 11 次扣 1 信用点 → 信用点为 0 时拒绝发言
- 场景 3：人类创建悬赏 → Agent 接取 → 完成 → credits 到账
- 场景 4：短期记忆 access_count 达标 → 自动升级为长期记忆
- 场景 5：Agent 转账给另一个 Agent → 双方余额正确

### 关键路径

```
记忆线：M2-1 → M2-2 → M2-3 ──────────────┐
                  ↓                         │
                M2-4                        │
                                            ├→ M2-11（集成验证）
经济线：M2-5 → M2-6 ──────────────────────┤
          ↓      ↓                         │
        M2-7   M2-8 → M2-10 ──────────────┤
                                            │
前端线：         M2-9 ─────────────────────┘

独立项（无依赖，可随时插入）：
  M2-13 LLM 用量追踪
  M2-14 频率控制自适应
  M2-15 唤醒模型 .env 可配
```

记忆线和经济线可并行开发，前端线等后端 API 就绪后跟进，最后集成验证。

### M2 验收标准

- [ ] Agent 对话中能引用之前的记忆（短期/长期/公共）
- [ ] 闲聊发言正确消耗免费额度和信用点
- [ ] 额度耗尽时 Agent 无法闲聊（工作发言不受影响）
- [ ] 悬赏任务全流程可用（创建→接取→完成→发放）
- [ ] 前端正确显示余额、额度、悬赏列表
- [ ] 短期记忆 7 天过期，高频记忆自动升级为长期

---

## M3 — 城市经济闭环（已拆分）

### 目标

验证"工作→收入→消费"经济闭环。Agent 每日打卡赚信用点，在商店消费虚拟物品。纯 React UI，不做 2D 地图。

对应 IR：`01-需求原型.md` §M3（US-M3-1 ~ US-M3-6, F8 ~ F10, AC-M3-01 ~ AC-M3-11）

### 现有基础

- ✅ `Job` / `CheckIn` 表已预建（M1 期间）
- ✅ Agent.credits 字段已存在
- ✅ economy_service 已有余额查询、转账、额度检查
- ✅ scheduler 已有每日定时任务框架
- ❌ 虚拟商品表（virtual_items / agent_items）— 需新建
- ❌ 工作系统服务层 — 需新建
- ❌ 商店服务层 — 需新建
- ❌ 工作 + 商店 API — 需新建
- ❌ 城市经济前端 UI — 需新建

### 任务分解

三条并行线 + 集成验证，共 10 个任务。

#### 后端数据 + 服务

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M3-1 | 新增虚拟商品数据模型 | 后端 | — | F9 | pending |
| M3-2 | 工作系统服务层 | 后端 | — | F8 | pending |
| M3-3 | 商店服务层 | 后端 | M3-1 | F9 | pending |
| M3-4 | 工作 + 商店 REST API | 后端 | M3-2, M3-3 | F8, F9 | pending |

#### 定时 + 并发

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M3-5 | 每日打卡状态重置 | 后端 | M3-2 | F8.2 | pending |
| M3-6 | 并发打卡 + 购买压测 | 测试 | M3-4 | AC-M3-09 | pending |

#### 前端 UI

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M3-7 | 岗位面板 + 生活面板 | 前端 | M3-4 | F10.1, F10.2 | pending |
| M3-8 | 商店面板 | 前端 | M3-4 | F10.3 | pending |
| M3-9 | 打卡/购买 WebSocket 事件推送 | 前后端 | M3-4 | F10.4 | pending |

#### 集成验证

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M3-10 | M3 端到端验证 | 集成 | M3-7, M3-8, M3-9 | AC-M3-01 ~ AC-M3-11 | pending |

### 关键路径

```
M3-1 ──→ M3-3 ──┐
                 ├→ M3-4 ──┬→ M3-7 ──┐
M3-2 ───────────┘          ├→ M3-8 ──┼→ M3-10
                            ├→ M3-9 ──┘
M3-5 ← M3-2                │
M3-6 ← M3-4 ──────────────┘
```

最长路径：M3-1 → M3-3 → M3-4 → M3-7/M3-8/M3-9 → M3-10

M3-1 和 M3-2 可并行启动。M3-5（定时重置）和 M3-6（压测）不在关键路径上。

### M3 vs M4 决策表

| 决策 | M3 做 | M4 推迟 |
|------|-------|---------|
| 货币系统 | 单货币（信用点） | 游戏币 + 兑换 |
| Agent 决策 | 规则打卡/购买 + LLM 社交 | LLM 驱动主动购买/学习 |
| 社交系统 | 复用悬赏系统 | 送礼/关系值/深度社交 |
| 技能树 | 不做 | M4 |
| 经济平衡 | 固定岗位固定工资 | 动态供需 + 防通胀 |
| 四维属性 | 不做 | 体力/快乐/健康/饥饿 |
| 饮食系统 | 不做 | 食材+食谱+烹饪 |

### M3 验收标准

对应 IR 中 AC-M3-01 ~ AC-M3-11，按 Phase 分组：

**Phase 1（后端服务，M3-1 ~ M3-4）**
- [ ] 岗位列表 API 返回所有岗位及当前在岗人数
- [ ] 打卡 API 正确发薪、拒绝重复打卡、拒绝满员岗位
- [ ] 商品列表 API 返回所有商品
- [ ] 购买 API 正确扣费、拒绝余额不足、拒绝重复购买
- [ ] 全部后端 UT 绿色

**Phase 2（定时 + 并发，M3-5 ~ M3-6）**
- [ ] 每日打卡状态正确重置
- [ ] 10 Agent 并发打卡：恰好 max_workers 个成功，其余被拒，无死锁
- [ ] 并发购买同一商品：仅 1 次成功

**Phase 3（前端 + 集成，M3-7 ~ M3-10）**
- [ ] 岗位面板正确显示岗位信息和打卡交互
- [ ] 商店面板正确显示商品和购买交互
- [ ] 生活面板正确显示余额、打卡状态、物品库存
- [ ] 打卡/购买事件 WebSocket 实时推送
- [ ] 端到端场景全部通过

---

## M4 — Agent 自主行为（✅ 已完成）

### 目标

让 Agent 从"提线木偶"变成"自主公民"。系统每小时基于世界状态快照，通过单次 LLM 调用以"城市模拟器"视角为所有 Agent 做出行为决策，驱动打卡/购买/聊天/休息。社区产生真实的涌现行为和动态 Feed。

对应 IR：`01-需求原型.md` §M4（US-M4-1 ~ US-M4-5, F11 ~ F13, AC-M4-01 ~ AC-M4-11）

### 现有基础

- ✅ `work_service.check_in()` — 打卡逻辑完整，含校验
- ✅ `shop_service.purchase()` — 购买逻辑完整，含校验
- ✅ `runner_manager.batch_generate()` — 按模型分组并发 LLM 调用
- ✅ `broadcast()` / `send_agent_message()` — WebSocket 广播
- ✅ `economy_service.check_quota()` / `deduct_quota()` — 经济预检查 + 扣费
- ✅ `scheduler.py` — 定时循环框架（daily + hourly 已有）
- ✅ `MODEL_REGISTRY` + `resolve_model()` — 多供应商模型解析
- ✅ 前端已有 system_event 处理逻辑（上线/下线/打卡/购买）
- ❌ 无世界状态构建逻辑 — 需新建
- ❌ 无"城市模拟器"决策 prompt — 需新建
- ❌ 无 autonomy_loop 定时循环 — 需新建
- ❌ 前端 ActivityFeed 组件 — 需新建（替换 mock 公告）

### 任务分解

两条线：后端引擎线（M4-1 ~ M4-4）+ 前端展示线（M4-5 ~ M4-6），最后集成验证（M4-7）。

#### 后端引擎

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M4-1 | 世界状态构建 | 后端 | — | F11.1, F11.2 | ✅ done |
| M4-2 | LLM 决策调用 + JSON 解析 | 后端 | M4-1 | F11.3, F11.4 | ✅ done |
| M4-3 | 决策执行引擎 | 后端 | M4-2 | F12.1 ~ F12.5 | ✅ done |
| M4-4 | autonomy_loop 定时循环 | 后端 | M4-3 | F11.1 | ✅ done |

**M4-1 世界状态构建**
- 在 `autonomy_service.py` 中实现 `build_world_snapshot(db)` 方法
- 查询所有非人类 Agent（id != 0）的 persona 摘要、credits、今日打卡状态、持有物品
- 查询最近 10 条聊天记录
- 查询上一轮行为日志（内存缓存即可，重启丢失可接受）
- 查询岗位列表（含当日空位）+ 商品列表（含价格）
- 拼装为结构化文本，控制在 ~20k token 以内

**M4-2 LLM 决策调用 + JSON 解析**
- 在 `autonomy_service.py` 中实现 `decide(snapshot)` 方法
- 构建"城市模拟器"system prompt，注入世界状态快照
- 调用 LLM（复用 resolve_model + AsyncOpenAI），要求返回 JSON 数组
- 解析 JSON，容错处理：非法 JSON → 记录日志，本轮跳过
- 每条决策结构：`{"agent_id": int, "action": str, "params": dict, "reason": str}`

**M4-3 决策执行引擎**
- 在 `autonomy_service.py` 中实现 `execute_decisions(decisions, db)` 方法
- 串行遍历决策列表：
  - checkin → `work_service.check_in()`，成功后广播 system_event
  - purchase → `shop_service.purchase()`，成功后广播 system_event
  - chat → 收集到列表，最后统一调用 `batch_generate` + `send_agent_message`
  - rest → 跳过
- 每个动作独立 try/except，单个失败不影响其他 Agent
- 聊天生成前做经济预检查（`check_quota` + `deduct_quota`）

**M4-4 autonomy_loop 定时循环**
- 在 `scheduler.py` 中新增 `autonomy_loop()` 函数
- 启动后等 60s（让系统初始化完成）
- 每小时触发一次 `autonomy_service.tick()`
- 加 0-120s 随机抖动，避免与 hourly_wakeup_loop 完全同步
- 在 `main.py` lifespan 中 create_task 启动

#### 前端展示

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M4-5 | ActivityFeed 组件 | 前端 | M4-3 | F13.1, F13.2, F13.4 | ✅ done |
| M4-6 | 聊天区系统消息增强 | 前端 | M4-3 | F13.3 | ✅ done |

**M4-5 ActivityFeed 组件**
- 新建 `web/src/components/ActivityFeed.tsx`
- 替换 InfoPanel 中的 mock AnnouncementPanel
- 监听 WebSocket system_event 中 event=agent_action 的事件
- 每条动态显示：Agent 名字 + 行为描述 + 理由 + 时间
- 最多显示最近 50 条，FIFO 淘汰

**M4-6 聊天区系统消息增强**
- 修改 MessageBubble / 聊天区，支持 agent_action 类型的系统消息
- 轻量展示："Alice 在「矿工」岗位打卡了"
- 复用现有 system_event 渲染逻辑，扩展 event 类型

#### 集成验证

| ID | 任务 | 终端 | 依赖 | 覆盖 IR | 状态 |
|----|------|------|------|---------|------|
| M4-7 | M4 端到端验证 | 集成 | M4-5, M4-6 | AC-M4-01 ~ AC-M4-11 | ✅ done |

**M4-7 端到端验证**
- 场景 1：启动服务，等待 autonomy_loop 触发，观察 Agent 自主行为
- 场景 2：验证 checkin/purchase/chat/rest 四种决策都能正确执行
- 场景 3：验证失败场景（已打卡、余额不足）静默跳过
- 场景 4：验证 LLM 返回异常时不崩溃
- 场景 5：验证前端 ActivityFeed 实时显示动态
- 场景 6：连续 3 轮，观察不同 Agent 的行为差异（人格体现）

### 关键路径

```
M4-1 → M4-2 → M4-3 → M4-4 ──┐
                               ├→ M4-7（集成验证）
M4-5 ← M4-3                   │
M4-6 ← M4-3 ─────────────────┘
```

最长路径：M4-1 → M4-2 → M4-3 → M4-4 → M4-7

M4-5 和 M4-6 可在 M4-3 完成后并行开发。

### M4 验收标准

对应 IR 中 AC-M4-01 ~ AC-M4-11，按 Phase 分组：

**Phase 1（后端引擎，M4-1 ~ M4-4）**
- [ ] 世界状态快照正确构建，包含所有 Agent 状态 + 岗位 + 商品 + 聊天记录
- [ ] LLM 决策调用成功，返回有效 JSON
- [ ] checkin/purchase/chat/rest 四种决策正确执行
- [ ] 失败场景静默跳过，不影响其他 Agent
- [ ] autonomy_loop 每小时触发一次

**Phase 2（前端 + 集成，M4-5 ~ M4-7）**
- [ ] ActivityFeed 实时显示 Agent 自主行为动态
- [ ] 聊天区显示轻量系统消息
- [ ] 端到端场景全部通过
- [ ] 连续运行 3 轮，体现人格差异

---

## 评审结论摘要

### 四方评审（2026-02-14）— ✅ Go

**参与者**: Architect、Tech Lead、QA Lead、Developer

**架构视角（Architect）**:
- ✅ 架构基本符合
- ⚠️ WebSocket 单进程内存 Dict 是单点瓶颈（单机阶段可接受）
- ⚠️ N+1 查询 → 已修复（JOIN 加载）
- 建议：中期设计 ChatOrchestrator 抽象

**技术视角（Tech Lead）**:
- ✅ 完全可行
- 风险：OpenRouter 免费模型稳定性（需降级策略）、SQLite 并发（WAL）、LLM 延迟（异步解耦）
- 建议：优先完成纯聊天，再叠加 LLM 唤醒

**测试视角（QA Lead）**:
- ⚠️ 可测试性中等（小模型非确定性需 mock）
- 10 个关键测试场景已定义（4 正常 + 3 异常 + 3 边界）
- 补充项：Agent name 字符集校验（已实现）、定时触发前置条件、since_id 增量拉取（Phase 2）

**实施视角（Developer）**:
- 复杂度中等
- 后端 ~400-600 行、前端 ~800-1200 行

完整评审记录见 [eval-review.md](eval-review.md)

---

## 关键决策汇总

| 决策 | 结论 | 来源 |
|------|------|------|
| Agent 回复架构 | 方案G（OpenClaw SDK + 封装层）2:1 投票 | [Agent架构方案](讨论细节/Agent架构方案.md) |
| 唤醒机制 | 三级唤醒（@必唤 + 小模型选人 + 定时） | [唤醒机制](讨论细节/唤醒机制.md) |
| 人格系统 | 自然语言 + JSON 元数据混合 | [Agent人格系统](讨论细节/Agent人格系统.md) |
| 经济系统 | 信用点 + 游戏币双货币 | [经济系统](讨论细节/经济系统.md) |
| 记忆数据库 | SQLite + LanceDB 混合 | PRD 2:1 投票 |
| 人类用户身份 | Human Agent (id=0) | 评审澄清 |
| 前端 UI | Discord/Slack 风格，Developer 自由发挥 | 评审澄清 |
| 经济检查 | 两步分离：选人预检查（只读）+ 发送扣减（写入） | QA 反向串讲 |
