# 错题本 — 💻 开发者 / 通用开发（前后端共用）

### DEV-1 后端终端改了前端文件

❌ 后端终端修改 `web/src/components/Chat.tsx`
✅ 后端终端只改 `server/`，前端问题通知前端终端处理
> 职责分离，避免冲突。

### DEV-2 改接口没更新契约文档

❌ 后端改了 `/api/agents` 的返回格式，没更新 `docs/api-contract.md`
✅ 改接口的同时更新 `docs/api-contract.md`，通知前端终端
> api-contract.md 是前后端唯一的协作边界。

### DEV-3 联调问题用双终端来回排查

❌ WebSocket 消息收不到，前端终端查一遍、后端终端查一遍，来回沟通
✅ 跨层问题用 Agent Team 联调（协调者 + 前端调试者 + 后端调试者）
> 简单问题单终端修，跨层问题用 Agent Team。

### DEV-4 复杂功能跳过需求评审

❌ 直接开始写代码，没有 REQ 文档
✅ 新功能先走四方需求评审（阶段1），产出 REQ-XXX.md
> 简单 Bug 可以跳过，复杂功能必须评审。

### DEV-5 实施不遵循 TDD 文档

❌ TDD 定义了接口格式，实施时自己改了字段名
✅ 严格按 TDD 实施，需要改设计先更新 TDD 再改代码
> TDD 是契约，改契约需要走流程。

### DEV-6 修复代码时只看 bug 点，不做影响面分析

❌ 改了变量赋值语义（增量→覆盖），没有检查下游引用是否仍成立，导致死代码、语义矛盾
✅ 修复前 grep 所有引用点，逐个确认改动后语义是否成立；改完后做"涟漪推演"
> 每次修复都改变代码结构，改变本身可能引入新的边界问题。目标是 review 循环 ≤2 轮。

**修复前必做检查清单**:
1. grep 被改变量/函数的所有引用点，逐个确认语义是否仍成立
2. 如果改变了赋值语义（增量→覆盖、必传→可选），追踪所有下游消费者
3. 改完后做"涟漪推演"：这个改动会让哪些下游行为变化？
4. 删参数/改签名时，grep 所有调用方 + 测试中的 assert
5. 不靠隐式假设保安全，用显式代码结构保安全（elif/identity check）

### DEV-7 把 pytest 单元测试当成 ST（系统测试）验证

❌ 被要求"启动 ST 测试"时，直接跑 `pytest tests/`，声称"全绿=验证通过"
✅ ST 测试 = 启动真实服务器 + 调用真实 API + 观察真实行为
> 单元测试全绿只能证明 mock 环境下逻辑正确，不能证明真实环境下端到端流程可用。

**区分清单**:
1. UT（单元测试）: `pytest tests/` — mock 依赖，验证函数逻辑
2. ST（系统测试）: 启动 uvicorn → curl/httpx 调用 API → 检查数据库/WebSocket 广播
3. E2E（端到端测试）: 前后端联调，浏览器/Playwright 驱动完整用户流程
