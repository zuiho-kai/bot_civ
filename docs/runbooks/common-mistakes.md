# 常见错误案例合集

> 本文件包含两部分：跨角色的通用错误 + 各角色错题本索引。

---

## 角色错题本索引

| 角色 | 错题本 | 覆盖范围 |
|------|--------|---------|
| 💻 开发者 | [error-book-dev.md](error-book-dev.md) | 前后端协作、代码实施、环境踩坑 |
| 📋 项目经理 | [error-book-pm.md](error-book-pm.md) | 进度记录、里程碑同步、上下文管理 |
| 🏗️ 架构师 / ⚖️ 讨论专家 | [error-book-debate.md](error-book-debate.md) | 讨论流程、方案设计、决策记录 |
| 🧪 QA Lead | [error-book-qa.md](error-book-qa.md) | 测试设计、测试执行、Bug 报告 |
| 📝 记录员 | [error-book-recorder.md](error-book-recorder.md) | 讨论落盘、索引维护、信息去重 |

---

## 通用错误（所有角色适用）

### COMMON-1 对话是临时的，文件是持久的

❌ 讨论完直接告诉用户结论，没有写文件
✅ 任何重要讨论/决策/进展，必须落盘到对应文件
> 对话丢了就没了，文件才是持久记忆。

### COMMON-2 多个文件记录同一信息

❌ 文档结构在 CLAUDE.md 写一遍，claude-progress.txt 又写一遍
✅ 只在一个地方维护，其他地方放链接
> 信息只有一个 source of truth，重复 = 不一致风险。

### COMMON-3 详细内容放在索引文件里

❌ discussions.md 里放完整的讨论过程（几百行）
✅ 索引文件只放表格/链接，详细内容在独立文件里
> 索引文件要轻，详细内容按需加载。

### COMMON-4 改了内容没更新索引

❌ 新建了文件，但 CLAUDE.md / discussions.md 等索引没加条目
✅ 新建文件的同时，更新所有相关索引
> 没索引 = 找不到 = 不存在。

### COMMON-5 角色越界操作

❌ 后端终端改前端文件、记录员做架构决策、PM 直接改代码
✅ 每个角色只做自己职责范围内的事，需要跨界时通知对应角色
> 职责分离是多 Agent 协作的基础。

### COMMON-6 跨模块语义假设不一致

❌ 模块A改变了核心概念的含义（如"Agent在线"从"有WebSocket连接"变成"服务端驱动"），但依赖该概念的模块B没有同步更新
✅ 当架构决策改变了某个概念的语义时，必须回溯所有依赖该概念的模块，更新其前提假设
> 典型案例：方案G改变了Agent存在方式，但唤醒服务的"在线"定义没跟着更新（DEV-BUG-5）。TDD中应明确列出跨模块依赖假设。

### COMMON-7 主 Agent 直接做低复杂度任务

❌ 索引同步、链接更新、进度记录等简单任务，主 Agent（Opus/Sonnet）亲自逐个文件读+改
✅ 派子 Agent 处理：`Task(model="haiku")` 做文档编辑/索引同步/链接更新/进度记录，`Task(model="sonnet")` 做需要理解上下文的简单修改
> 主 Agent 是调度器，不是执行器。格式化任务（添加索引、更新链接、记录进度）必须用 haiku 子 agent，省 token 省成本。参考 [模型选择策略](model-selection.md)。

**实际案例**（2026-02-14）：
- 用户要求添加 `eval-review.md` 到 SPEC-001 索引
- 主 Agent（Sonnet）直接用 Glob/Read/Edit 完成
- 应该做法：`Task(model="haiku", prompt="添加 eval-review.md 到 SPEC-001/README.md 索引")`
- 成本差异：Sonnet 处理简单文档编辑浪费约 3-5 倍成本

### COMMON-8 技术选型的隐含约束全链路漏检

❌ 选择技术栈（如 SQLite）时只评估功能匹配度，没有列出该技术在项目场景下的隐含约束（如并发写入必须 BEGIN IMMEDIATE），导致从需求→架构→TDD→Code Review→测试全链路无人看护
✅ 技术选型时必须产出**约束清单**，写入架构文档，并在 TDD、Code Review checklist、测试用例中逐层体现
> 隐含约束不会在单连接/happy path 中暴露，只在真实并发场景才爆炸。如果选型时不主动挖掘，后续每个环节都会默认"没问题"。

**全链路看护要求**:
1. **架构师**：选型时列出技术约束清单（并发限制、必要配置、已知坑），写入架构文档
2. **TDD 设计**：数据库/中间件模块的 TDD 必须包含非功能规格（事务隔离、并发策略）
3. **Code Review**：checklist 增加技术约束核查项（如"SQLite 是否配置了 BEGIN IMMEDIATE？"）
4. **QA**：测试用例必须包含并发写入场景，不能只测单连接 happy path
5. **PM**：需求评审时主动追问非功能需求（并发安全性、性能约束）

**实际案例**（DEV-BUG-7 + DEV-BUG-8，耗时 2h+，成本 200 刀）：
- SQLite + aiosqlite 需要 BEGIN IMMEDIATE 才能安全并发写入
- 需求评审没提并发安全性、架构没列约束、TDD 没写事务策略、Review 没查配置、测试没覆盖并发
- 五个环节全部漏检，直到生产级 e2e 测试才暴露

### COMMON-9 "我觉得我懂"陷阱 — 连续猜方案不搜索

❌ 看到熟悉的错误信息（如 "database is locked"），凭已有知识连续尝试多个方案，每次失败后换下一个"我知道的"方案
✅ **两次失败后必须停下来搜索根因**，不要继续猜
> "知道一点"比"完全不知道"更危险。如果完全不懂会去搜索，但"觉得自己懂"会跳过搜索直接动手，在表面原因上反复打转。

**三步止血规则（遇到不熟悉的技术问题时）**:
1. **先搜索，不要猜**（5 分钟上限）: 遇到明确错误信息，第一步搜索 "[技术栈] + [错误信息]"，大多数常见问题都有现成答案
2. **最小脚本验证，不要跑完整流程**（省 80% token）: 写 10 行脚本复现问题并验证方案，不要每次都启动完整服务 + 跑 e2e
3. **两次失败后停下来重新思考**（硬性规则）: 连续两个方案失败 = 对问题的理解有误，必须重新分析根因

**实际案例**（DEV-BUG-7，耗时 2h，成本 200 刀，详见 COMMON-8）：
- SQLite "database is locked" 错误，连续尝试 9 个方案（timeout → WAL → NullPool → asyncio.Lock → ...），全部失败
- 第 10 次才去搜索，5 分钟找到正确答案（BEGIN IMMEDIATE）
- 如果第 2 次失败后就搜索，20 分钟 20 刀就能解决，节省 180 刀

---
角色专属错误追加到对应角色的错题本，格式：

```markdown
### [角色前缀]-[编号] 简短标题

❌ 错误做法
✅ 正确做法
> 一句话解释为什么。
```

实际 Bug 踩坑：

```markdown
### [角色前缀]-BUG-[编号] 简短标题

- **场景**: 什么情况下触发
- **现象**: 看到了什么
- **原因**: 根因是什么
- **修复**: 怎么解决的
```
