# OpenClaw 社区项目

> 自动加载：本文件 + `claude-progress.txt`
> 详细文档按需读取：`docs/` 目录

## 语言与协作规则

1. **全中文输出**：所有对话、文档、注释、commit message 一律使用中文
2. **方案评审流程**：任何新功能/改造方案，必须先提交给人类替身 PM（`docs/personas/human-proxy-pm.md`）评审，PM 确认没问题后再与开发者（用户）对齐实施细节。不允许跳过 PM 评审直接开干
3. **PM 评审问题逐个对齐**：PM 评审产出的待确认问题，必须逐个提交给用户决策，禁止打包。每个问题独立提供背景 + 选项，用户拍板后再进入下一个

## 核心规则

1. **强制记录**：里程碑完成 → 更新 `claude-progress.txt` 顶部"最近活动"
2. **分层进度**：小改动记 `server/progress.md`，大里程碑记 `claude-progress.txt`（详见 `docs/PROGRESS_FILES.md`）
3. **讨论记录**：功能相关 → `docs/specs/SPEC-XXX/讨论细节/`，项目通用 → `docs/discussions/`。**创建讨论文件后必须同步更新 `docs/discussions.md` 索引**（快速总结 + 索引表都要更新），子 agent 落盘时也必须在 prompt 中包含此要求
4. **防丢失**：对话是临时的，文件是持久的
5. **代码导航**：不确定功能在哪个文件？查看 `docs/CODE_MAP.md`
6. **不做口头承诺**：任何教训/流程改进/规则变更，发现的当下直接写入对应文件，不要口头说"以后会这样做"（详见 COMMON-12）

## 里程碑门控规则

每个新里程碑（M1, M2, M3...）必须按顺序完成三层文档，缺一不可，不允许跳步：

| 阶段 | 文档 | 只写什么 | 不写什么 | 门控 |
|------|------|----------|----------|------|
| IR（需求原型） | `01-需求原型.md` 对应章节 | 用户故事、功能点、验收标准、非功能需求 | 技术方案、文件路径、伪代码 | 用户确认后才能进入 SR |
| SR（需求拆分） | `02-需求拆分.md` 对应章节 | 里程碑目标、任务 ID/名称/依赖/状态、验收标准、关键路径 | 具体函数签名、seed 数据、实现伪代码 | 用户确认后才能进入 AR |
| AR（技术设计） | `TDD-M*-xxx.md` | 架构图、接口定义、伪代码、数据流、文件清单、测试计划 | 产品需求重复、用户故事 | 用户确认后才能开始编码 |

**强制检查点**：
- 开始新里程碑前，确认上一个里程碑的 IR/SR/AR 均已完成或标记为"远期"
- 讨论记录（`docs/discussions/`）不等于正式文档，讨论中的设计决策必须提炼回 SPEC 对应层级
- 发现跳步时立即停下，补齐缺失层级，不要带着缺口继续推进

## 工作流

- 简单任务 → 直接实施
- 复杂任务 → 读 `docs/personas/human-proxy-pm.md` 对齐意图 → 协作讨论 → 拆解实施
- **新里程碑** → 先走 IR → SR → AR 门控流程（见上方），每层用户确认后再进入下一层
  - **AR 完成后不能直接编码**，必须按 `docs/workflows/development-workflow.md` 继续：
  - 阶段 3：正向串讲（Developer → QA Lead）— 复杂功能必须，简单修改可跳过
  - 阶段 4：反向串讲（QA Lead → Developer）— 与正向串讲同步
  - 阶段 5：测试用例设计（QA Lead 输出 TEST-XXX.md）
  - **阶段 6 开发实施**：以上全部完成后才能开始写代码
- 完成任务 → ⚠️ **更新进度文件前必须确认**：该 Phase 是否已完成 Code Review 循环（P0/P1 归零）？未完成则先 Review 再更新
- **代码修复流程** → 实现 → 自验证 → Code Review → 修复 → 重新 Review → 循环直到 P0/P1 归零（详见 COMMON-10）
  - **强制门禁**：每个 Phase 实现完毕后，必须先完成 Code Review 循环（P0/P1 归零），才能更新进度文件或进入下一步。不允许跳过。
- **编码前自查清单**（详见 DEV-14）：
  1. grep 同类功能的已有实现，复用项目 pattern（延迟发送、广播、session 管理等）
  2. 写完后逐条对照 TDD 检查：函数签名、消息格式、prompt 内容、容错边界
  3. 每个 try/except 块检查异常路径的变量可达性
  4. 不擅自偏离 TDD，改进想法先更新设计文档再改代码
  5. 替换组件/模块时，grep 旧名称的所有引用逐个清除（文件、import、类型、mock、CSS）
  6. 对照 TDD 用户故事编号逐个勾选，不凭感觉"差不多了"
  7. 生成 id/key 时考虑并发碰撞：避免 Date.now() 裸用，优先自增计数器或负数隔离
  8. 时间相关 UI 考虑"用户停留 30 分钟后"的表现
- **每次修复前必做影响面分析**：grep 引用点 + 追踪下游 + 涟漪推演（详见 DEV-6）
- **每个 Phase 完成后必须跑 ST**：拉起真实服务器 + 调用真实 API + 检查真实数据库，不能只跑 pytest（详见 QA-6）
- **出问题自动落盘流程**（不需要用户提醒）：
  - ⚠️ **逐步执行，不要凭印象跳步**：每完成一步再做下一步，第 2 步必须实际调用 Read 工具读文件，不能跳过
  1. 分析根因 + 溯源各阶段遗漏
  2. **实际调用 Read 读目标错题本顶部的"记录规则"**，确认行数上限（COMMON-14）— 不能跳过此步
  3. 错题本写摘要（≤行数上限），按角色写入对应 `docs/runbooks/error-books/error-book-{role}.md`
  4. 详细复盘放 `docs/runbooks/postmortems/postmortem-dev-bug-N.md`，错题本里放链接
  5. 更新进度文件
- **回溯流程**（用户说"回溯"时触发）：
  1. 回顾刚完成的工作，列出卡点时间线 → 分析根因和浪费轮次 → 提炼可优化点
  2. 落盘到错题本（遵循上述落盘流程，先回读记录规则再写）
  3. 详细回溯表放 postmortem（详见 COMMON-13）
- **dev endpoint 设计规范**：支持 `?debug=1` 返回中间状态；阈值参数可通过 dev API 覆盖；错误路径返回具体原因（详见 COMMON-13、QA-7）
- **调研/搜索任务必须并行**：需要搜索多个主题时（如技术选型对比），用多个并行 Task agent 同时搜索，不要串行逐个搜
- **网页浏览优先级**：查看网页内容时，优先级为 jina.ai（最佳内容提取）→ Playwright 浏览器（可视化）→ WebFetch（最后选择）
- **工具调用失败不盲目重试**：工具调用报错后，必须读错误信息、修正参数再重试，不允许用相同参数重复调用。连续 2 次同一错误 → 停下来换思路（详见 DEV-8）
- **多问题批量修复先分类再并行**：拿到多个问题/体验反馈时，先花 1 分钟分类（纯 CSS / 前端逻辑 / 后端 / 配置），同类问题并行处理；空文件/空日志只读一次；"操作后没反应"先查前端状态流转再怀疑后端（详见 DEV-12）
- **外部 CLI 集成先做 4 步环境探针**：① which cli ② 检查 HTTPS_PROXY/HTTP_PROXY ③ 读认证配置文件 ④ 手动跑一条命令——探针全过才开始写脚本（详见 DEV-12）
- **429 quota 错误判断**：有 retryDelay 秒数 = RPM 速率限制（等待即可）；无 retryDelay = 真正用尽；`limit:0` ≠ 永久无配额（详见 DEV-12）
- **"删掉X"指令先确认范围**：用户说"删掉"时，先问清是删功能/删某个存储位置/删配置，不要默认删所有相关存储（详见 DEV-12）

## 双终端分工

- 后端：`server/`（API、数据库、Agent、LLM）
- 前端：`web/`（React UI、WebSocket）
- 接口契约：`docs/api-contract.md`

## 文档速查

- 角色定义：`docs/personas/roles.md`
- 功能规格：`docs/specs/SPEC-001-聊天功能/README.md`
- 讨论索引：`docs/discussions.md`
- PRD：`docs/PRD.md`
- 代码导航：`docs/CODE_MAP.md`（功能→文件映射）
- 进度文件说明：`docs/PROGRESS_FILES.md`（避免混淆）
